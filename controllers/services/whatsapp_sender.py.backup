import time
import os
import psutil
import shutil
import subprocess
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.edge.service import Service
from selenium.webdriver.edge.options import Options
from selenium.webdriver.common.keys import Keys
from typing import Optional, Callable, Tuple
from dataclasses import dataclass
from datetime import datetime

@dataclass
class SendResult:
    success: bool
    message: str
    phone_sent_to: str
    timestamp: str
    import sys
    
    def custom_log(msg):
        """Callback personalizado para logging no main."""
        print(f"[MAIN] {msg}", flush=True)
    
    custom_log("=== Teste do WhatsAppSender ===")
    
    sender = WhatsAppSender(log_callback=custom_log, verbose=True)
    
    custom_log("\n1. Inicializando...")
    success, msg = sender.initialize(log_callback=custom_log)
    custom_log(f"Resultado: {success} - {msg}\n")
    
    if success:
        custom_log("2. Aguardando login...")
        success, msg = sender.wait_for_login(log_callback=custom_log)
        custom_log(f"Resultado: {success} - {msg}\n")
        
        if success:
            try:
                number = input("\n3. Digite o número de telefone (com código do país): ")
                msg_text = input("4. Digite a mensagem: ")
                
                custom_log("\n5. Enviando mensagem...")
                result = sender.send_message(number, msg_text, log_callback=custom_log)
                custom_log(f"\nResultado do envio:")
                custom_log(f"  Success: {result.success}")
                custom_log(f"  Message: {result.message}")
                custom_log(f"  Phone: {result.phone_sent_to}")
                custom_log(f"  Timestamp: {result.timestamp}")
            except KeyboardInterrupt:
                custom_log("\n\nInterrompido pelo utilizador")
        
        input("\n\nPressione ENTER para fechar...")
        sender.close(log_callback=custom_log)
    
    custom_log("\n=== Teste concluído ===")
bdriver.edge.service import Service
from selenium.webdriver.edge.options import Options
from selenium.webdriver.common.keys import Keys
from typing import Optional, Callable, Tuple
from dataclasses import dataclass
from datetime import datetime

@dataclass
class SendResult:
    success: bool
    message: str
    phone_sent_to: str
    timestamp: str

class WhatsAppSender:    
    WHATSAPP_URL = "https://web.whatsapp.com"
    LOGIN_TIMEOUT = 120
    LOAD_TIMEOUT = 20 
    
    def __init__(self, log_callback: Optional[Callable] = None, verbose: bool = False):
        self.driver: Optional[webdriver.Edge] = None
        self._driver_process = None
        # Cria uma pasta específica para isolar totalmente do Edge pessoal
        self.session_dir = os.path.abspath(os.path.join(os.path.expanduser("~"), ".whatsapp_edge_session"))
        self._default_log = log_callback
        self.verbose = verbose
        
        self._log("WhatsAppSender criado")
    
    def _log(self, msg: str, log_callback: Optional[Callable] = None, level: str = "info"):
        """Helper para logging consistente."""
        log_func = log_callback or self._default_log
        if log_func:
            if self.verbose or level != "debug":
                timestamp = datetime.now().strftime("%H:%M:%S")
                log_func(f"[{timestamp}] {msg}")
    
    @property
    def is_logged_in(self) -> bool:
        if not self.driver: return False
        try:
            return len(self.driver.find_elements(By.CSS_SELECTOR, '#pane-side')) > 0
        except:
            return False
    
    def _kill_specific_session_processes(self, log_callback: Optional[Callable] = None) -> bool:
        self._log("Procurando processos da sessão específica...", log_callback, "debug")
        killed = False
        target_names = ['msedge.exe', 'msedgewebview2.exe']
        # O driver pode ser morto sem problemas
        driver_names = ['msedgedriver.exe'] 

        for attempt in range(2):
            if attempt > 0 and not killed: break
            
            for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
                try:
                    p_info = proc.info
                    p_name = (p_info['name'] or "").lower()
                    p_cmd = " ".join(p_info['cmdline'] or []).lower()
                    
                    if any(d in p_name for d in driver_names):
                        proc.kill()
                        killed = True
                        self._log(f"Driver morto: PID {p_info['pid']}", log_callback, "debug")
                    elif any(t in p_name for t in target_names):
                        # Só mata se o processo tiver a nossa pasta de sessão nos argumentos
                        if self.session_dir.lower() in p_cmd or '.whatsapp_edge_session' in p_cmd:
                            proc.kill()
                            killed = True
                            self._log(f"Edge da sessão morto: PID {p_info['pid']}", log_callback, "debug")
                except: continue
            
            if killed: time.sleep(0.5)
        
        if killed: 
            time.sleep(1)
            self._log("Processos da sessão limpos", log_callback)
        else:
            self._log("Nenhum processo conflituoso", log_callback, "debug")
        return killed
    
    def _cleanup_session_locks(self, log_callback: Optional[Callable] = None) -> bool:
        if not os.path.exists(self.session_dir): return True
        self._log("Limpando locks de sessão...", log_callback, "debug")
        lock_files = ["SingletonLock", "SingletonSocket", "SingletonCookie", "lockfile"]
        cleaned = 0
        for fname in lock_files:
            fpath = os.path.join(self.session_dir, fname)
            if os.path.exists(fpath):
                try: 
                    os.remove(fpath)
                    cleaned += 1
                except: pass 
        if cleaned > 0:
            self._log(f"{cleaned} lock(s) removido(s)", log_callback, "debug")
        return True
    
    def _prepare_session_directory(self, log_callback: Optional[Callable] = None, force_clean: bool = False) -> bool:
        if force_clean and os.path.exists(self.session_dir):
            self._log("Limpando sessão (force_clean=True)...", log_callback)
            try: shutil.rmtree(self.session_dir); time.sleep(0.5)
            except: pass
        os.makedirs(self.session_dir, exist_ok=True)
        self._log(f"Diretório de sessão pronto: {self.session_dir}", log_callback, "debug")
        return self._cleanup_session_locks(log_callback)
    
    def _get_edge_driver_service(self, log_callback=None):
        local = os.path.join(os.getcwd(), "msedgedriver.exe")
        if os.path.exists(local): 
            self._log("Usando msedgedriver local", log_callback, "debug")
            return Service(executable_path=local)
        try:
            self._log("Obtendo driver via webdriver-manager...", log_callback, "debug")
            from webdriver_manager.microsoft import EdgeChromiumDriverManager
            return Service(executable_path=EdgeChromiumDriverManager().install())
        except:
            self._log("Usando Service padrão", log_callback, "debug")
            return Service()

    def _create_edge_options(self, log_callback: Optional[Callable] = None) -> Options:
        self._log("Configurando opções do Edge...", log_callback, "debug")
        options = Options()
        options.add_argument(f"--user-data-dir={self.session_dir}")
        options.add_argument("--profile-directory=Default")
        options.add_argument("--remote-debugging-port=9225")
        options.add_experimental_option("detach", True)
        
        args = [
            "--no-service-autorun", "--disable-gpu", "--no-sandbox", 
            "--disable-dev-shm-usage", "--disable-notifications", 
            "--log-level=3", "--silent"
        ]
        for arg in args: options.add_argument(arg)
        options.add_experimental_option('excludeSwitches', ['enable-automation', 'enable-logging'])
        self._log("Opções configuradas (porta 9225)", log_callback, "debug")
        return options

    def initialize(self, log_callback: Optional[Callable] = None, force_clean_session: bool = False) -> Tuple[bool, str]:
        self._log("Inicializando em modo isolado...", log_callback)
        
        try:
            self._kill_specific_session_processes(log_callback)
            self._prepare_session_directory(log_callback, force_clean_session)
            
            options = self._create_edge_options(log_callback)
            service = self._get_edge_driver_service(log_callback)
            
            # Flags para esconder a janela do console do driver (não do browser)
            if service:
                service.creation_flags = 0x08000000 | 0x00000008 | 0x00000200

            self._log("Criando driver...", log_callback)
            try:
                self.driver = webdriver.Edge(service=service, options=options)
                self._log("✓ Driver criado", log_callback)
            except Exception as e:
                if "user data" in str(e):
                    self._log("Conflito, tentando novamente...", log_callback)
                    self._kill_specific_session_processes(log_callback)
                    time.sleep(2)
                    self.driver = webdriver.Edge(service=service, options=options)
                    self._log("✓ Driver criado (2ª tentativa)", log_callback)
                else:
                    raise e

            self._log("Abrindo WhatsApp...", log_callback)
            self.driver.get(self.WHATSAPP_URL)
            
            try:
                self.driver.minimize_window()
                self._log("Janela minimizada", log_callback, "debug")
            except:
                pass
            
            self._log("✓ Inicialização concluída", log_callback)
            return True, "Iniciado"
            
        except Exception as e:
            self._log(f"✗ Erro fatal: {e}", log_callback)
            return False, str(e)
    
    def wait_for_login(self, timeout: int = 120, log_callback: Optional[Callable] = None) -> Tuple[bool, str]:
        if not self.driver: return False, "Driver Off"
        
        if self.is_logged_in:
            return True, "Já logado"
            
        self._log("Necessário Login (QR Code). Restaurando janela...")
        try:
            # Se precisar de login, mostra a janela para o utilizador ver
            self.driver.maximize_window() 
        except: pass

        self._log("Aguardando QR Code...")
        try:
            WebDriverWait(self.driver, timeout).until(
                EC.presence_of_element_located((By.CSS_SELECTOR, '#pane-side'))
            )
            self._log("Login detectado! Minimizando...")
            try: self.driver.minimize_window()
            except: pass
            return True, "Logado"
        except:
            return False, "Timeout"

    def _wait_for_chat_load_or_error(self, timeout: int) -> str:
        end_time = time.time() + timeout
        input_css = 'div[contenteditable="true"][data-tab="10"]'
        input_css_alt = 'footer div[contenteditable="true"]' 
        
        while time.time() < end_time:
            try:
                if len(self.driver.find_elements(By.CSS_SELECTOR, input_css)) > 0: return 'input'
                if len(self.driver.find_elements(By.CSS_SELECTOR, input_css_alt)) > 0: return 'input'

                body_text = self.driver.find_element(By.TAG_NAME, 'body').text
                if "número de telemóvel" in body_text.lower() and "inválido" in body_text.lower():
                    return 'invalid'
                if "phone number shared via url is invalid" in body_text.lower():
                    return 'invalid'
            except: pass
            time.sleep(0.2)
        return 'timeout'

    def send_message(self, phone: str, message: str, log_callback: Optional[Callable] = None) -> SendResult:
        phone = ''.join(filter(str.isdigit, phone))
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        if not self.driver: return SendResult(False, "Driver off", phone, timestamp)

        try:
            self.driver.get(f"https://web.whatsapp.com/send?phone={phone}")
            
            state = self._wait_for_chat_load_or_error(self.LOAD_TIMEOUT)
            if state == 'invalid': return SendResult(False, "Número Inválido", phone, timestamp)
            elif state == 'timeout': return SendResult(False, "Timeout Chat", phone, timestamp)
            
            try:
                input_box = self.driver.find_element(By.CSS_SELECTOR, 'div[contenteditable="true"][data-tab="10"]')
            except:
                input_box = self.driver.find_element(By.CSS_SELECTOR, 'footer div[contenteditable="true"]')
            
            # Envio limpo e direto
            input_box.click()
            input_box.send_keys(Keys.CONTROL, 'a')
            input_box.send_keys(Keys.BACK_SPACE)
            
            lines = message.split('\n')
            for i, line in enumerate(lines):
                input_box.send_keys(line)
                if i < len(lines) - 1:
                    input_box.send_keys(Keys.SHIFT, Keys.ENTER)
            
            input_box.send_keys(Keys.ENTER)
            
            self._log(f"Comando enviado para {phone}", level="info")
            return SendResult(True, "Enviado", phone, timestamp)

        except Exception as e:
            self._log(f"Erro envio: {e}", level="info")
            return SendResult(False, str(e), phone, timestamp)

    def close(self):
        if self.driver:
            try: self.driver.quit()
            except: pass
        self.driver = None

# Teste rápido
if __name__ == "__main__":    
    sender = WhatsAppSender(log_callback=print, verbose=True)
    
    ok, msg = sender.initialize()
    if ok:
        sender.wait_for_login()
        number = input("In o número de telefone (no formato xxxxxxxxx): ")
        result = sender.send_message(number, "Teste")
        print(result)
        sender.close()